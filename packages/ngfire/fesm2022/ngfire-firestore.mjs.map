{"version":3,"file":"ngfire-firestore.mjs","sources":["../../../../libs/ngfire/firestore/src/operators.ts","../../../../libs/ngfire/firestore/src/tokens.ts","../../../../libs/ngfire/firestore/src/query.ts","../../../../libs/ngfire/firestore/src/firestore.ts","../../../../libs/ngfire/firestore/src/utils.ts","../../../../libs/ngfire/firestore/src/document.ts","../../../../libs/ngfire/firestore/src/collection.ts","../../../../libs/ngfire/firestore/src/sub-collection.ts","../../../../libs/ngfire/firestore/src/ngfire-firestore.ts"],"sourcesContent":["import type { DocumentData, DocumentReference, DocumentSnapshot, Query, QuerySnapshot, SnapshotListenOptions } from \"firebase/firestore\";\r\nimport { onSnapshot } from 'firebase/firestore';\r\nimport { Observable } from \"rxjs\";\r\n\r\nconst DEFAULT_OPTIONS = { includeMetadataChanges: false };\r\nexport function fromRef<T=DocumentData>(ref: DocumentReference<T>, options?: SnapshotListenOptions): Observable<DocumentSnapshot<T>>;\r\nexport function fromRef<T=DocumentData>(ref: Query<T>, options?: SnapshotListenOptions): Observable<QuerySnapshot<T>>;\r\nexport function fromRef<T=DocumentData>(\r\n  ref: DocumentReference<T> | Query<T>,\r\n  options: SnapshotListenOptions\r\n): Observable<DocumentSnapshot<T>> | Observable<QuerySnapshot<T>>;\r\nexport function fromRef<T=DocumentData>(\r\n  ref: any,\r\n  options: SnapshotListenOptions = DEFAULT_OPTIONS\r\n): Observable<any> {\r\n  /* eslint-enable @typescript-eslint/no-explicit-any */\r\n  return new Observable(subscriber => {\r\n    const unsubscribe = onSnapshot<T, DocumentData>(ref, options, {\r\n      next: subscriber.next.bind(subscriber),\r\n      error: subscriber.error.bind(subscriber),\r\n      complete: subscriber.complete.bind(subscriber),\r\n    });\r\n    return { unsubscribe };\r\n  });\r\n}","import { inject, InjectionToken } from \"@angular/core\";\r\nimport { Firestore } from 'firebase/firestore';\r\nimport { initializeFirestore } from \"firebase/firestore\";\r\nimport { FIRESTORE_SETTINGS, getConfig } from \"ngfire/tokens\";\r\nimport { FIREBASE_APP } from \"ngfire/app\";\r\n\r\n\r\nexport const FIRESTORE = new InjectionToken<Firestore>('Firestore instance', {\r\n  providedIn: 'root',\r\n  factory: () => {\r\n    const config = getConfig();\r\n    const settings = inject(FIRESTORE_SETTINGS, { optional: true });\r\n    const app = inject(FIREBASE_APP);\r\n    if (config.firestore) {\r\n      return config.firestore(app, settings ?? {});\r\n    } else {\r\n      return initializeFirestore(app, settings ?? {});\r\n    }\r\n  },\r\n});\r\n","import type { Query } from 'firebase/firestore';\r\nimport { exist } from 'ngfire/core';\r\n\r\n\r\n// Simplfied version of\r\n// https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/core/query.ts#L442\r\nexport function stringifyQuery(query: Query) {\r\n  if ('_query' in query) {\r\n    const target = (query as any)['_query'] as any & { limitType: string };\r\n    return `${stringifyTarget(target)}|lt:${target.limitType})`;\r\n  }\r\n  return '';\r\n}\r\n\r\nfunction stringifyTarget(target: any): string {\r\n  if (!target.orderBy) (target as any).orderBy = [];\r\n  let str = target.path.canonicalString();\r\n  if (target.collectionGroup !== null) {\r\n    str += '|cg:' + target.collectionGroup;\r\n  }\r\n  if (target.filters.length > 0) {\r\n    const fields = target.filters\r\n    .map((f: any) => stringifyFilter(f as any))\r\n    .join(', ');\r\n    str += `|f:[${fields}]`;\r\n  }\r\n  if (exist(target.limit)) {\r\n    str += '|l:' + target.limit;\r\n  }\r\n  if (target.orderBy.length > 0) {\r\n    const order = target.orderBy\r\n    .map((o: any) => stringifyOrderBy(o))\r\n    .join(', ');\r\n    str += `|ob:[${order}]`;\r\n  }\r\n  if (target.startAt) {\r\n    str += '|lb:';\r\n    str += target.startAt.inclusive ? 'b:' : 'a:';\r\n    str += target.startAt.position.map((p: any) => canonifyValue(p)).join(',');\r\n  }\r\n  if (target.endAt) {\r\n    str += '|ub:';\r\n    str += target.endAt.inclusive ? 'a:' : 'b:';\r\n    str += target.endAt.position.map((p: any) => canonifyValue(p)).join(',');\r\n  }\r\n  return str;\r\n}\r\n\r\n/** Returns a debug description for `filter`. */\r\nexport function stringifyFilter(filter: any): string {\r\n  return `${filter.field.canonicalString()} ${filter.op} ${canonifyValue(filter.value)}`;\r\n}\r\n\r\nexport function stringifyOrderBy(orderBy: any): string {\r\n  return `${orderBy.field.canonicalString()} (${orderBy.dir})`;\r\n}\r\n\r\n/* eslint-disable */\r\nfunction canonifyValue(value: any): string {\r\n  if ('nullValue' in value) {\r\n    return 'null';\r\n  } else if ('booleanValue' in value) {\r\n    return '' + value.booleanValue;\r\n  } else if ('integerValue' in value) {\r\n    return '' + value.integerValue;\r\n  } else if ('doubleValue' in value) {\r\n    return '' + value.doubleValue;\r\n  } else if ('timestampValue' in value) {\r\n    return canonifyTimestamp(value.timestampValue!);\r\n  } else if ('stringValue' in value) {\r\n    return value.stringValue!;\r\n  } else if ('bytesValue' in value) {\r\n    return canonifyByteString(value.bytesValue!);\r\n  } else if ('referenceValue' in value) {\r\n    return value.referenceValue!;\r\n  } else if ('geoPointValue' in value) {\r\n    return canonifyGeoPoint(value.geoPointValue!);\r\n  } else if ('arrayValue' in value) {\r\n    return canonifyArray(value.arrayValue!);\r\n  } else if ('mapValue' in value) {\r\n    return canonifyMap(value.mapValue!);\r\n  } else {\r\n    throw new Error('Invalid value type: ' + JSON.stringify(value));\r\n  }\r\n}\r\n/* eslint-enable */\r\n\r\n\r\nfunction canonifyByteString(byteString: string | Uint8Array): string {\r\n  if (typeof byteString === 'string') return byteString;\r\n  return byteString.toString();\r\n}\r\n\r\n\r\n\r\nfunction canonifyTimestamp(timestamp: any): string {\r\n  return `time(${timestamp.toString()})`;\r\n}\r\n\r\nfunction canonifyGeoPoint(geoPoint: any): string {\r\n  return `geo(${geoPoint.latitude},${geoPoint.longitude})`;\r\n}\r\n\r\nfunction canonifyMap(mapValue: any): string {\r\n  // Iteration order in JavaScript is not guaranteed. To ensure that we generate\r\n  // matching canonical IDs for identical maps, we need to sort the keys.\r\n  const sortedKeys = Object.keys(mapValue.fields || {}).sort();\r\n  // eslint-disable-next-line\r\n  const content = sortedKeys.map(key => `${key}:${canonifyValue(mapValue.fields![key])}`).join(',');\r\n  return `{${content}}`;\r\n}\r\n\r\nfunction canonifyArray(arrayValue: any): string {\r\n  const values = arrayValue.values || [];\r\n  return `[${values.map(canonifyValue).join(',')}]`;\r\n}\r\n","import { inject, Injectable, Injector, PLATFORM_ID, makeStateKey, TransferState } from \"@angular/core\";\r\nimport { collection, doc, DocumentData, DocumentSnapshot, query, queryEqual, QuerySnapshot, runTransaction, writeBatch } from 'firebase/firestore';\r\nimport type { Transaction, CollectionReference, DocumentReference, Query, QueryConstraint } from 'firebase/firestore';\r\nimport { FIRESTORE } from \"./tokens\";\r\nimport { shareWithDelay, assertCollection, assertPath, isCollectionRef, isDocPath, isQuery } from \"ngfire/core\";\r\nimport { fromRef } from \"./operators\";\r\nimport { isPlatformBrowser, isPlatformServer } from \"@angular/common\";\r\nimport { Observable } from \"rxjs\";\r\nimport { stringifyQuery } from \"./query\";\r\n\r\ntype Reference<E> = CollectionReference<E> | DocumentReference<E>;\r\ntype Snapshot<E = DocumentData> = DocumentSnapshot<E> | QuerySnapshot<E>;\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class FirestoreService {\r\n  private memoryRef: Record<string, Observable<Snapshot>> = {};\r\n  private injector = inject(Injector);\r\n  private plateformId = inject(PLATFORM_ID);\r\n  /** Transfer state between server and  */\r\n  private transferState = inject(TransferState, { optional: true });\r\n  /** Cache based state for document */\r\n  private state: Map<string | Query, Snapshot<unknown>> = new Map();\r\n\r\n  get db() {\r\n    return this.injector.get(FIRESTORE);\r\n  }\r\n\r\n  /** @internal Should only be used by FireCollection services */\r\n  setState<E>(\r\n    ref: DocumentReference<E> | CollectionReference<E> | Query<E>,\r\n    snap: Snapshot<E>\r\n  ) {\r\n    if (isCollectionRef(ref)) {\r\n      (snap as QuerySnapshot<E>).forEach(doc => this.state.set(doc.ref.path, doc));\r\n      this.state.set(ref.path, snap);\r\n    } else if (isQuery(ref)) {\r\n      (snap as QuerySnapshot<E>).forEach(doc => this.state.set(doc.ref.path, doc));\r\n      const key = stringifyQuery(ref);\r\n      this.state.set(key, snap);\r\n    } else {\r\n      this.state.set(ref.path, snap);\r\n    }\r\n  }\r\n\r\n  getState<E>(ref: DocumentReference<E>, delay?: number): DocumentSnapshot<E>\r\n  getState<E>(ref: CollectionReference<E>, delay?: number): QuerySnapshot<E>\r\n  getState<E>(ref: Query<E>, delay?: number): QuerySnapshot<E>\r\n  getState<E>(ref: DocumentReference<E> | CollectionReference<E> | Query<E>): Snapshot<E> | undefined\r\n  getState<E>(ref: DocumentReference<E> | CollectionReference<E> | Query<E>): Snapshot<E> | undefined {\r\n    if (isQuery(ref)) {\r\n      const key = stringifyQuery(ref);\r\n      return this.state.get(key) as Snapshot<E>;\r\n    } else {\r\n      return this.state.get(ref.path) as Snapshot<E>;\r\n    }\r\n  }\r\n\r\n  /** @internal Should only be used by FireCollection services */\r\n  fromMemory<E>(ref: DocumentReference<E>, delay?: number): Observable<DocumentSnapshot<E>>\r\n  fromMemory<E>(ref: CollectionReference<E>, delay?: number): Observable<QuerySnapshot<E>>\r\n  fromMemory<E>(ref: Query<E>, delay?: number): Observable<QuerySnapshot<E>>\r\n  fromMemory<E>(ref: DocumentReference<E> | CollectionReference<E> | Query<E>, delay?: number): Observable<Snapshot<E>>\r\n  fromMemory<E>(\r\n    ref: DocumentReference<E> | CollectionReference<E> | Query<E>,\r\n    delay?: number\r\n  ): Observable<Snapshot<E>> {\r\n    const key = isQuery(ref) ? stringifyQuery(ref) : ref.path;\r\n    if (!this.memoryRef[key]) {\r\n      this.memoryRef[key] = fromRef(ref as any).pipe(shareWithDelay(delay));\r\n    }\r\n    return this.memoryRef[key] as Observable<Snapshot<E>>;\r\n  }\r\n\r\n  /**\r\n   * @internal Should only be used by FireCollection services\r\n   * Get the transfer state for a specific ref and put it in the memory state\r\n   * Remove the reference to transfer state after first call\r\n   */\r\n  getTransfer<E>(ref: DocumentReference<E>): E | undefined\r\n  getTransfer<E>(ref: CollectionReference<E> | Query<E>): E[] | undefined\r\n  getTransfer<E>(ref: DocumentReference<E> | CollectionReference<E> | Query<E>): E[] | E | undefined\r\n  getTransfer<E>(ref: DocumentReference<E> | CollectionReference<E> | Query<E>) {\r\n    if (!this.transferState || !isPlatformBrowser(this.plateformId)) return;\r\n    const key = isQuery(ref) ? stringifyQuery(ref) : ref.path;\r\n    const stateKey = makeStateKey<E>(key);\r\n    if (!this.transferState.hasKey(stateKey)) return;\r\n    const value = this.transferState.get(stateKey, undefined);\r\n    this.transferState.remove(stateKey);\r\n    return value;\r\n  }\r\n\r\n  /** @internal Should only be used by FireCollection services */\r\n  setTransfer<E>(ref: DocumentReference<E>, value?: E): void\r\n  setTransfer<E>(ref: DocumentReference<E>[] | CollectionReference<E> | Query<E>, value?: E[]): void\r\n  setTransfer<E>(ref: DocumentReference<E> | DocumentReference<E>[] | CollectionReference<E> | Query<E>, value?: E | E[]): void\r\n  setTransfer<E>(ref: DocumentReference<E> | DocumentReference<E>[] | CollectionReference<E> | Query<E>, value?: E | E[]) {\r\n    if (!value) return;\r\n    if (!this.transferState || !isPlatformServer(this.plateformId)) return;\r\n    if (Array.isArray(ref) && Array.isArray(value)) {\r\n      ref.forEach((reference, i) => this.setTransfer(reference, value[i]));\r\n    } else if (!Array.isArray(ref)) {\r\n      const key = isQuery(ref) ? stringifyQuery(ref) : ref.path;\r\n      this.transferState.set(makeStateKey<E>(key), value);\r\n    }\r\n  }\r\n\r\n\r\n  clearCache(paths: string | string[] | Query) {\r\n    if (!paths) return;\r\n    if (Array.isArray(paths)) {\r\n      for (const path of paths) {\r\n        delete this.memoryRef[path];\r\n        this.state.delete(path);\r\n      }\r\n    } else if (typeof paths === 'string') {\r\n      delete this.memoryRef[paths];\r\n      this.state.delete(paths);\r\n    } else {\r\n      const key = stringifyQuery(paths);\r\n      delete this.memoryRef[key];\r\n      this.state.delete(key);\r\n    }\r\n  }\r\n\r\n  /** Get the reference of the document, collection or query */\r\n  public getRef<E>(path: string): Reference<E>;\r\n  public getRef<E>(paths: string[]): DocumentReference<E>[];\r\n  public getRef<E>(path: string, constraints: QueryConstraint[]): Query<E>;\r\n  // overload used internally when looping over paths array\r\n  public getRef<E>(\r\n    paths: string | string[],\r\n    constraints?: QueryConstraint[],\r\n  ): undefined | Query<E> | Query<E>[] | Reference<E> | DocumentReference<E>[] {\r\n    if (!arguments.length || !paths) return undefined;\r\n\r\n    // Array of docs\r\n    if (Array.isArray(paths)) {\r\n      return paths.map((path) => this.getRef<E>(path) as DocumentReference<E>);\r\n    }\r\n\r\n    const hasContraints = Array.isArray(constraints);\r\n    if (hasContraints) {\r\n      assertPath(paths);\r\n      assertCollection(paths);\r\n      const ref = collection(this.db, paths) as CollectionReference<E>;\r\n      return query(ref, ...constraints);\r\n    } else {\r\n      assertPath(paths);\r\n      if (isDocPath(paths)) return doc(this.db, paths) as DocumentReference<E>;\r\n      return collection(this.db, paths) as CollectionReference<E>;\r\n    }\r\n  }\r\n\r\n  batch() {\r\n    return writeBatch(this.db);\r\n  }\r\n\r\n  runTransaction<T>(cb: (transaction: Transaction) => Promise<T>) {\r\n    return runTransaction<T>(this.db, (tx) => cb(tx));\r\n  }\r\n\r\n  createId() {\r\n    return doc(collection(this.db, '__')).id;\r\n  }\r\n\r\n}","import { Timestamp } from \"firebase/firestore\";\r\n\r\n/** Return the full path of the doc */\r\nexport function getDocPath(path: string, id: string) {\r\n  // If path is smaller than id, id is the full path from ref\r\n  return path.split('/').length < id.split('/').length ? id : `${path}/${id}`;\r\n}\r\n\r\n/** Recursively all Timestamp into Date */\r\nexport function toDate<D>(target: D): D {\r\n  if (typeof target !== 'object') return target;\r\n  for (const key in target) {\r\n    const value = target[key];\r\n    if (!value || typeof value !== 'object') continue;\r\n    if (value instanceof Timestamp) {\r\n      target[key] = value.toDate() as any;\r\n      continue;\r\n    }\r\n    toDate(value)\r\n  }\r\n  return target;\r\n}\r\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\r\nimport { inject, NgZone, PLATFORM_ID } from '@angular/core';\r\nimport { writeBatch, runTransaction, getDoc, Transaction, DocumentSnapshot, FieldValue, setDoc, updateDoc } from 'firebase/firestore';\r\nimport type { DocumentData, DocumentReference, QueryDocumentSnapshot, WriteBatch } from 'firebase/firestore';\r\nimport { fromRef } from './operators';\r\nimport type { WriteOptions, UpdateCallback, MetaDocument, Params, FireEntity, DeepKeys } from 'ngfire/core';\r\nimport { keepUnstableUntilFirst, pathWithParams } from 'ngfire/core';\r\nimport { Observable, from, firstValueFrom } from 'rxjs';\r\nimport { tap, startWith, switchMap } from 'rxjs/operators';\r\n\r\nimport { isPlatformServer } from '@angular/common';\r\nimport { FirestoreService } from './firestore';\r\nimport { toDate } from './utils';\r\n\r\n/////////////\r\n// SERVICE //\r\n/////////////\r\n\r\nexport abstract class FireDocument<E extends DocumentData> {\r\n  protected platformId = inject(PLATFORM_ID);\r\n  protected zone = inject(NgZone);\r\n  protected firestore = inject(FirestoreService);\r\n  protected abstract readonly path: string;\r\n  protected idKey: DeepKeys<E> = 'id' as any;\r\n  /** If true, will store the document id (IdKey) onto the document */\r\n  protected storeId = false;\r\n  /**\r\n   * Cache the snapshot into a global store\r\n   */\r\n  protected memorize = false;\r\n  /**\r\n   * Delay before unsubscribing to a query (used only with memorized is true)\r\n   * Use Infinty for application long subscription\r\n   */\r\n  protected delayToUnsubscribe = 0;\r\n\r\n  protected onCreate?(entity: E, options: WriteOptions): unknown;\r\n  protected onUpdate?(entity: FireEntity<E>, options: WriteOptions): unknown;\r\n  protected onDelete?(path: string, options: WriteOptions): unknown;\r\n\r\n\r\n  protected get db() {\r\n    return this.firestore.db;\r\n  }\r\n\r\n  protected useCache<T extends E>(ref: DocumentReference<T>): Observable<T | undefined> {   \r\n    if (isPlatformServer(this.platformId)) {\r\n      return this.zone.runOutsideAngular(() => fromRef(ref)).pipe(\r\n        switchMap(async snap => this.snapToData(snap)),\r\n        tap(value => this.firestore.setTransfer(ref, value)),\r\n        keepUnstableUntilFirst(this.zone),\r\n      );\r\n    }\r\n    if (!this.memorize) {\r\n      return this.zone.runOutsideAngular(() => fromRef(ref)).pipe(\r\n        switchMap(async snap => this.snapToData(snap)),\r\n        keepUnstableUntilFirst(this.zone)\r\n      );\r\n    }\r\n    const transfer = this.firestore.getTransfer(ref);\r\n    const initial = this.firestore.getState(ref);\r\n    const snap$ = this.zone.runOutsideAngular(() => this.firestore.fromMemory<T>(ref, this.delayToUnsubscribe)).pipe(\r\n      tap(snap => this.firestore.setState(ref, snap)),\r\n      keepUnstableUntilFirst(this.zone)\r\n    );\r\n    if (transfer) return snap$.pipe(switchMap(async snap => this.snapToData(snap)), startWith(transfer));\r\n    if (initial) return snap$.pipe(startWith(initial), switchMap(async snap => this.snapToData(snap)));\r\n    return snap$.pipe(switchMap(async snap => this.snapToData(snap)));\r\n  }\r\n\r\n  protected clearCache<T extends E>(ref: DocumentReference<T>) {\r\n    return this.firestore.clearCache(ref.path);\r\n  }\r\n\r\n  /** Function triggered when adding/updating data to firestore */\r\n  protected toFirestore<T extends E = E>(entity: FireEntity<T>, actionType: 'create' | 'update'): any | Promise<any> {\r\n    if (actionType === 'create') {\r\n      const _meta: MetaDocument = { createdAt: new Date(), modifiedAt: new Date() };\r\n      return { _meta, ...entity };\r\n    } else {\r\n      return { ...entity, '_meta.modifiedAt': new Date() };\r\n    }\r\n  }\r\n\r\n  /** Function triggered when getting data from firestore */\r\n  protected fromFirestore<T extends E = E>(snapshot: DocumentSnapshot<T> | QueryDocumentSnapshot<T>): Promise<T> | T | undefined {\r\n    if (snapshot.exists()) {\r\n      return { ...toDate(snapshot.data()), [this.idKey]: snapshot.id };\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  batch() {\r\n    return writeBatch(this.db);\r\n  }\r\n\r\n  runTransaction<T>(cb: (transaction: Transaction) => Promise<T>) {\r\n    return runTransaction<T>(this.db, (tx) => cb(tx));\r\n  }\r\n\r\n  createId(params?: Params) {\r\n    return this.getRef(params)?.id;\r\n  }\r\n\r\n\r\n  /** Get the content of the snapshot */\r\n  protected snapToData<T extends E = E>(snap: DocumentSnapshot<T>) {\r\n    return this.fromFirestore<T>(snap);\r\n  }\r\n\r\n  /** Get the content of reference(s) */\r\n  protected async getFromRef<T extends E = E>(ref: DocumentReference<T>): Promise<T | undefined> {\r\n    const snap = await getDoc(ref);\r\n    return this.snapToData(snap);\r\n  }\r\n\r\n  /** Observable the content of reference(s)  */\r\n  protected fromRef<T extends E = E>(ref: DocumentReference<T>): Observable<T | undefined> {\r\n    return this.useCache(ref);\r\n  }\r\n\r\n  ///////////////\r\n  // SNAPSHOTS //\r\n  ///////////////\r\n\r\n  /** Get the reference of the document, collection or query */\r\n  public getRef<T extends E>(parameters?: Params): DocumentReference<T> {\r\n    const path = parameters ? pathWithParams(this.path, parameters) : this.path;\r\n    const ref = this.firestore.getRef<T>(path) as DocumentReference<T>;\r\n    if (!ref) throw new Error(`Could not create a reference out of path \"${path}\"`);\r\n    return ref;\r\n  }\r\n\r\n  /** Clear cache and get the latest value into the cache */\r\n  public async reload<T extends E = E>(parameters?: Params): Promise<T | undefined> {\r\n    if (!this.memorize) return;\r\n    const ref = this.getRef(parameters);\r\n    this.clearCache(ref);\r\n    return this.load(parameters);\r\n  }\r\n\r\n  /** Get the last content from the app (if value has been cached, it won't do a server request) */\r\n  public async load<T extends E>(parameters?: Params): Promise<T | undefined> {\r\n    return firstValueFrom(this.valueChanges(parameters));\r\n  }\r\n\r\n  /** Return the current value of the document from Firestore */\r\n  public async getValue<T extends E = E>(parameters?: Params): Promise<T | undefined> {\r\n    const ref = this.getRef<T>(parameters);\r\n    return this.getFromRef<T>(ref);\r\n  }\r\n\r\n  /** Listen to the changes of values of the document from Firestore */\r\n  public valueChanges<T extends E = E>(parameters?: Params): Observable<T | undefined> {\r\n    const ref = this.getRef<T>(parameters);\r\n    return this.fromRef<T>(ref);\r\n  }\r\n\r\n\r\n  ///////////\r\n  // WRITE //\r\n  ///////////\r\n  /**\r\n   * Create or update the document\r\n   * @param document The document to upsert\r\n   * @param options options to write the document on firestore\r\n   */\r\n  async upsert<T extends E>(document: FireEntity<T>, options: WriteOptions = {}): Promise<string> {\r\n    const id: string | FieldValue | undefined = document[this.idKey];\r\n    if (typeof id !== 'string') return this.create(document, options);\r\n    const ref = this.getRef(options.params);\r\n    const snap = (options?.write instanceof Transaction)\r\n      ? await options.write?.get(ref)\r\n      : await getDoc(ref);\r\n    if (snap.exists()) return this.create(document, options);\r\n    await this.update(document, options);\r\n    return id;\r\n  }\r\n\r\n  /**\r\n   * Create the document at the specified path\r\n   * @param document The document to create\r\n   * @param options options to write the document on firestore\r\n   */\r\n  async create<T extends E>(document: FireEntity<T>, options: WriteOptions = {}): Promise<string> {\r\n    const baseId: string | FieldValue | undefined = document[this.idKey];\r\n    const id = typeof baseId === 'string' ? baseId : this.createId();\r\n    const data = await this.toFirestore(document, 'create');\r\n    if (this.storeId) data[this.idKey] = id;\r\n    const ref = this.getRef(options.params);\r\n    if (options.write) {\r\n      (options.write as WriteBatch).set(ref, data);\r\n    } else {\r\n      await setDoc(ref, data);\r\n    }\r\n    if (this.onCreate) {\r\n      await this.onCreate(data, { write: options.write, ctx: options.ctx });\r\n    }\r\n    return id;\r\n  }\r\n\r\n  /**\r\n   * Delete the document from firestore\r\n   * @param options options to write the document on firestore\r\n   */\r\n  async delete<T extends E>(options: WriteOptions = {}) {\r\n    const { write = this.batch(), ctx, params } = options;\r\n    const ref = this.getRef<T>(params);\r\n    write.delete(ref);\r\n    if (this.onDelete) {\r\n      await this.onDelete(ref.path, { write, ctx });\r\n    }\r\n    // If there is no atomic write provided\r\n    if (!options.write) {\r\n      await (write as WriteBatch).commit();\r\n      if (this.memorize) this.clearCache(ref);\r\n    }\r\n  }\r\n\r\n  /** Update document in Firestore */\r\n  update<T extends E>(document: FireEntity<T>, options?: WriteOptions): Promise<void>;\r\n  update<T extends E>(documentChanges: UpdateCallback<T>, options?: WriteOptions): Promise<void>;\r\n  async update<T extends E>(\r\n    changes: UpdateCallback<T> | FireEntity<T>,\r\n    options: WriteOptions = {}\r\n  ): Promise<void> {\r\n    const ref = this.getRef<T>(options.params);\r\n    if (typeof changes === 'function') {\r\n      await runTransaction(this.db, async (tx) => {\r\n        const snapshot = await tx.get(ref);\r\n        const doc = await this.fromFirestore<T>(snapshot);\r\n        if (doc && changes) {\r\n          const data = await changes(doc, tx);\r\n          const result = await this.toFirestore(data, 'update');\r\n          tx.update(ref, result);\r\n          if (this.onUpdate) {\r\n            await this.onUpdate(data, { write: tx, ctx: options.ctx });\r\n          }\r\n        }\r\n      });\r\n    } else {\r\n      const doc = await this.toFirestore<T>(changes, 'update');\r\n      if (options.write) {\r\n        (options.write as WriteBatch).update(ref, doc);\r\n      } else {\r\n        await updateDoc(ref, doc);\r\n      }\r\n      if (this.onUpdate) {\r\n        await this.onUpdate(doc, { write: options.write, ctx: options.ctx });\r\n      }\r\n    }\r\n    if (this.memorize) this.clearCache(ref);\r\n\r\n  }\r\n}\r\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\r\nimport { inject, NgZone, PLATFORM_ID } from '@angular/core';\r\nimport { writeBatch, runTransaction, doc, collection, Query, getDocs, getDoc, Transaction, DocumentSnapshot, FieldValue } from 'firebase/firestore';\r\nimport type { DocumentData, CollectionReference, DocumentReference, QueryConstraint, QueryDocumentSnapshot, QuerySnapshot, WriteBatch } from 'firebase/firestore';\r\nimport { fromRef } from './operators';\r\nimport type { WriteOptions, UpdateCallback, MetaDocument, Params, FireEntity, DeepKeys } from 'ngfire/core';\r\nimport { keepUnstableUntilFirst, isIdList, isNotUndefined, isPathRef, isQuery, pathWithParams } from 'ngfire/core';\r\nimport { Observable, of, combineLatest, from, firstValueFrom } from 'rxjs';\r\nimport { map, tap, startWith } from 'rxjs/operators';\r\n\r\nimport { isPlatformServer } from '@angular/common';\r\nimport { FirestoreService } from './firestore';\r\nimport { toDate, getDocPath } from './utils';\r\n\r\n/////////////\r\n// SERVICE //\r\n/////////////\r\n\r\nexport abstract class FireCollection<E extends DocumentData> {\r\n  protected platformId = inject(PLATFORM_ID);\r\n  protected zone = inject(NgZone);\r\n  protected firestore = inject(FirestoreService);\r\n  protected abstract readonly path: string;\r\n  protected idKey: DeepKeys<E> = 'id' as any;\r\n  /** If true, will store the document id (IdKey) onto the document */\r\n  protected storeId = false;\r\n  /**\r\n   * Cache the snapshot into a global store\r\n   */\r\n  protected memorize = false;\r\n  /**\r\n   * Delay before unsubscribing to a query (used only with memorized is true)\r\n   * Use Infinty for application long subscription\r\n   */\r\n  protected delayToUnsubscribe = 0;\r\n\r\n  protected onCreate?(entity: E, options: WriteOptions): unknown;\r\n  protected onUpdate?(entity: FireEntity<E>, options: WriteOptions): unknown;\r\n  protected onDelete?(id: string, options: WriteOptions): unknown;\r\n\r\n\r\n  protected get db() {\r\n    return this.firestore.db;\r\n  }\r\n\r\n  protected useCache<T extends E>(ref: DocumentReference<T>): Observable<T>\r\n  protected useCache<T extends E>(ref: Query<T>): Observable<T[]>\r\n  protected useCache<T extends E>(ref: DocumentReference<T> | Query<T>): Observable<T | T[]>\r\n  protected useCache<T extends E>(ref: DocumentReference<T> | Query<T>): Observable<T | T[]> {\r\n    if (isPlatformServer(this.platformId)) {\r\n      return this.zone.runOutsideAngular(() => fromRef(ref as Query<T>)).pipe(\r\n        map(snap => this.snapToData(snap)),\r\n        tap(value => this.firestore.setTransfer(ref, value)),\r\n        keepUnstableUntilFirst(this.zone)\r\n      );\r\n    }\r\n    if (!this.memorize) {\r\n      return this.zone.runOutsideAngular(() => fromRef(ref as Query<T>)).pipe(\r\n        map(snap => this.snapToData(snap)),\r\n        keepUnstableUntilFirst(this.zone)\r\n      );\r\n    }\r\n    const transfer = this.firestore.getTransfer(ref);\r\n    const initial = this.firestore.getState(ref);\r\n    const snap$ = this.zone.runOutsideAngular(() => this.firestore.fromMemory(ref, this.delayToUnsubscribe)).pipe(\r\n      tap(snap => this.firestore.setState(ref, snap)),\r\n      keepUnstableUntilFirst(this.zone)\r\n    );\r\n    if (transfer) return snap$.pipe(map(snap => this.snapToData(snap)), startWith(transfer));\r\n    if (initial) return snap$.pipe(startWith(initial), map(snap => this.snapToData(snap)));\r\n    return snap$.pipe(map(snap => this.snapToData(snap)));\r\n  }\r\n\r\n  protected clearCache<T extends E>(refs: CollectionReference<T> | DocumentReference<T> | Query<T> | DocumentReference<T>[]) {\r\n    if (Array.isArray(refs)) return this.firestore.clearCache(refs.map(ref => ref.path));\r\n    if (isQuery(refs)) return this.firestore.clearCache(refs);\r\n    return this.firestore.clearCache(refs?.path);\r\n  }\r\n\r\n  /** Function triggered when adding/updating data to firestore */\r\n  protected toFirestore(entity: FireEntity<E>, actionType: 'add' | 'update'): any | Promise<any> {\r\n    if (actionType === 'add') {\r\n      const _meta: MetaDocument = { createdAt: new Date(), modifiedAt: new Date() };\r\n      return { _meta, ...entity };\r\n    } else {\r\n      return { ...entity, '_meta.modifiedAt': new Date() };\r\n    }\r\n  }\r\n\r\n  /** Function triggered when getting data from firestore */\r\n  protected fromFirestore(snapshot: DocumentSnapshot<E> | QueryDocumentSnapshot<E>): E | undefined {\r\n    if (snapshot.exists()) {\r\n      return { ...toDate(snapshot.data()), [this.idKey]: snapshot.id };\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  batch() {\r\n    return writeBatch(this.db);\r\n  }\r\n\r\n  runTransaction<T>(cb: (transaction: Transaction) => Promise<T>) {\r\n    return runTransaction<T>(this.db, (tx) => cb(tx));\r\n  }\r\n\r\n  createId() {\r\n    return doc(collection(this.db, '__')).id;\r\n  }\r\n\r\n\r\n  /** Get the content of the snapshot */\r\n  protected snapToData<T extends E = E>(snap: DocumentSnapshot<T>): T;\r\n  protected snapToData<T extends E = E>(snap: DocumentSnapshot<T>[]): T[];\r\n  protected snapToData<T extends E = E>(snap: QuerySnapshot<T>): T[];\r\n  protected snapToData<T extends E = E>(snap: QuerySnapshot<T> | DocumentSnapshot<T> | DocumentSnapshot<T>[]): T | T[];\r\n  protected snapToData<T extends E = E>(snap: QuerySnapshot<T> | DocumentSnapshot<T> | DocumentSnapshot<T>[]): T | T[] {\r\n    if (snap instanceof DocumentSnapshot) return this.fromFirestore(snap) as T;\r\n    const snaps = Array.isArray(snap) ? snap : snap.docs;\r\n    return snaps.map(s => this.snapToData(s)).filter(isNotUndefined);\r\n  }\r\n\r\n  /** Get the content of reference(s) */\r\n  protected async getFromRef<T extends E = E>(ref: DocumentReference<T>): Promise<T | undefined>;\r\n  protected async getFromRef<T extends E = E>(ref: DocumentReference<T>[]): Promise<T[]>;\r\n  protected async getFromRef<T extends E = E>(ref: CollectionReference<T> | Query<T>): Promise<T[]>;\r\n  protected async getFromRef<T extends E = E>(\r\n    ref: DocumentReference<T> | DocumentReference<T>[] | CollectionReference<T> | Query<T>\r\n  ): Promise<undefined | T | T[]>;\r\n  protected async getFromRef<T extends E = E>(\r\n    ref: DocumentReference<T> | DocumentReference<T>[] | CollectionReference<T> | Query<T>\r\n  ): Promise<undefined | T | T[]> {\r\n    if (Array.isArray(ref)) return Promise.all(ref.map(getDoc)).then(snaps => this.snapToData(snaps));\r\n    const snap = (ref.type === 'document') ? await getDoc(ref) : await getDocs(ref);\r\n    return this.snapToData(snap);\r\n  }\r\n\r\n  /** Observable the content of reference(s)  */\r\n  protected fromRef<T extends E = E>(ref: DocumentReference<T>): Observable<T | undefined>;\r\n  protected fromRef<T extends E = E>(ref: DocumentReference<T>[]): Observable<T[]>;\r\n  protected fromRef<T extends E = E>(ref: CollectionReference<T> | Query<T>): Observable<T[]>;\r\n  protected fromRef<T extends E = E>(\r\n    ref: DocumentReference<T> | DocumentReference<T>[] | CollectionReference<T> | Query<T>\r\n  ): Observable<undefined | T | T[]>;\r\n  protected fromRef<T extends E = E>(\r\n    ref: DocumentReference<T> | DocumentReference<T>[] | CollectionReference<T> | Query<T>\r\n  ): Observable<undefined | T | T[]> {\r\n    if (Array.isArray(ref)) {\r\n      if (!ref.length) return of([]);\r\n      const queries = ref.map(r => this.useCache(r));\r\n      return combineLatest(queries);\r\n    } else {\r\n      return this.useCache(ref);\r\n    }\r\n  }\r\n\r\n  ///////////////\r\n  // SNAPSHOTS //\r\n  ///////////////\r\n\r\n  /** Get the reference of the document, collection or query */\r\n  public getRef<T extends E = E>(): CollectionReference<T>;\r\n  public getRef<T extends E = E>(ids: string[], params?: Params): DocumentReference<T>[];\r\n  public getRef<T extends E = E>(constraints: QueryConstraint[], params: Params): Query<T>;\r\n  public getRef<T extends E = E>(id: string, params?: Params): DocumentReference<T>;\r\n  public getRef<T extends E = E>(path: string, params?: Params): DocumentReference<T> | CollectionReference<T>;\r\n  public getRef<T extends E = E>(params: Params): CollectionReference<T>;\r\n  public getRef<T extends E = E>(\r\n    ids?: string | string[] | Params | QueryConstraint[],\r\n    params?: Params\r\n  ): undefined | Query<T> | CollectionReference<T> | DocumentReference<T> | DocumentReference<T>[]\r\n  public getRef<T extends E>(\r\n    ids?: string | string[] | Params | QueryConstraint[],\r\n    parameters?: Params\r\n  ): undefined | Query<T> | CollectionReference<T> | DocumentReference<T> | DocumentReference<T>[] {\r\n    // Collection\r\n    if (!arguments.length) return this.firestore.getRef(this.path);\r\n    // Id is undefined or null\r\n    if (!ids) return undefined;\r\n\r\n    if (Array.isArray(ids)) {\r\n      // List of ref\r\n      if ((ids as any[]).every(isPathRef)) return this.firestore.getRef(ids as string[]);\r\n\r\n      const path = pathWithParams(this.path, parameters);\r\n      // List of ids\r\n      if (isIdList(ids)) return this.firestore.getRef(ids.map((id) => getDocPath(path, id)));\r\n      // List of constraints\r\n      return this.firestore.getRef(path, ids);\r\n    }\r\n\r\n    if (typeof ids === 'string') {\r\n      // Ref\r\n      if (isPathRef(ids)) return this.firestore.getRef(ids);\r\n      // Id\r\n      const path = pathWithParams(this.path, parameters);\r\n      return this.firestore.getRef(getDocPath(path, ids));\r\n    }\r\n\r\n    // Subcollection\r\n    return this.firestore.getRef(pathWithParams(this.path, ids));\r\n  }\r\n\r\n\r\n  /** Clear cache and get the latest value into the cache */\r\n  public async reload<T extends E = E>(ids?: string[]): Promise<T[]>;\r\n  public async reload<T extends E = E>(query?: QueryConstraint[]): Promise<T[]>;\r\n  public async reload<T extends E = E>(id?: string | null): Promise<T | undefined>;\r\n  public async reload<T extends E = E>(\r\n    idOrQuery?: string | string[] | QueryConstraint[] | null,\r\n  ): Promise<T | T[] | undefined>\r\n  public async reload<T extends E = E>(): Promise<T | T[] | undefined> {\r\n    if (!this.memorize) return;\r\n    const ref = this.getRef(...arguments);\r\n    if (!ref) return;\r\n    this.clearCache(ref);\r\n    return this.load(...arguments);\r\n  }\r\n\r\n  /** Get the last content from the app (if value has been cached, it won't do a server request) */\r\n  public async load<T extends E = E>(ids?: string[]): Promise<T[]>;\r\n  public async load<T extends E = E>(query?: QueryConstraint[]): Promise<T[]>;\r\n  public async load<T extends E = E>(id?: string | null): Promise<T | undefined>;\r\n  public async load<T extends E = E>(\r\n    idOrQuery?: string | string[] | QueryConstraint[] | null,\r\n  ): Promise<T | T[] | undefined>\r\n  public async load<T extends E>(): Promise<T | T[] | undefined> {\r\n    return firstValueFrom(this.valueChanges(...arguments));\r\n  }\r\n\r\n  /** Return the current value of the path from Firestore */\r\n  public async getValue<T extends E = E>(ids?: string[]): Promise<T[]>;\r\n  public async getValue<T extends E = E>(query?: QueryConstraint[]): Promise<T[]>;\r\n  public async getValue<T extends E = E>(id?: string | null): Promise<T | undefined>;\r\n  public async getValue<T extends E = E>(idOrQuery?: null | string | string[] | QueryConstraint[]): Promise<T | T[] | undefined>\r\n  public async getValue<T extends E = E>(): Promise<T | T[] | undefined> {\r\n    const ref = this.getRef<T>(...arguments);\r\n    if (!ref) return;\r\n    return this.getFromRef<T>(ref);\r\n  }\r\n\r\n  /** Listen to the changes of values of the path from Firestore */\r\n  public valueChanges<T extends E = E>(ids?: string[]): Observable<T[]>;\r\n  public valueChanges<T extends E = E>(query?: QueryConstraint[]): Observable<T[]>;\r\n  public valueChanges<T extends E = E>(id?: string | null): Observable<T | undefined>;\r\n  public valueChanges<T extends E = E>(\r\n    idOrQuery?: string | string[] | QueryConstraint[] | null,\r\n  ): Observable<T | T[] | undefined>;\r\n  public valueChanges<T extends E = E>(\r\n    idOrQuery?: string | string[] | QueryConstraint[] | null,\r\n  ): Observable<T | T[] | undefined> {\r\n    if (Array.isArray(idOrQuery) && !idOrQuery.length) return of([]);\r\n    const ref = this.getRef<T>(...arguments);\r\n    if (!ref) return of(undefined);\r\n    return this.fromRef<T>(ref);\r\n  }\r\n\r\n\r\n  ///////////\r\n  // WRITE //\r\n  ///////////\r\n  /**\r\n   * Create or update documents\r\n   * @param documents One or many documents\r\n   * @param options options to write the document on firestore\r\n   */\r\n  upsert<T extends E>(documents: FireEntity<T>, options?: WriteOptions): Promise<string>;\r\n  upsert<T extends E>(documents: FireEntity<T>[], options?: WriteOptions): Promise<string[]>;\r\n  async upsert<T extends E>(\r\n    documents: FireEntity<T> | FireEntity<T>[],\r\n    options: WriteOptions = {}\r\n  ): Promise<string | string[]> {\r\n    const doesExist = async (doc: FireEntity<T>) => {\r\n      const id: string | FieldValue | undefined = doc[this.idKey];\r\n      if (typeof id !== 'string') return false;\r\n      const ref: any = this.getRef(id, options.params);\r\n      const snap = (options.write instanceof Transaction)\r\n        ? await options.write?.get(ref)\r\n        : await getDoc(ref);\r\n      return snap.exists();\r\n    };\r\n    const upsert = async (doc: FireEntity<T>) => {\r\n      const exists = await doesExist(doc);\r\n      if (!exists) return this.add(doc, options);\r\n      await this.update(doc, options);\r\n      return doc[this.idKey] as string;\r\n    }\r\n    return Array.isArray(documents)\r\n      ? Promise.all(documents.map(upsert))\r\n      : upsert(documents);\r\n  }\r\n\r\n  /**\r\n   * Add a document or a list of document to Firestore\r\n   * @param docs A document or a list of document\r\n   * @param options options to write the document on firestore\r\n   */\r\n  add<T extends E>(documents: FireEntity<T>, options?: WriteOptions): Promise<string>;\r\n  add<T extends E>(documents: FireEntity<T>[], options?: WriteOptions): Promise<string[]>;\r\n  async add<T extends E>(\r\n    documents: FireEntity<T> | FireEntity<T>[],\r\n    options: WriteOptions = {}\r\n  ): Promise<string | string[]> {\r\n    const docs = Array.isArray(documents) ? documents : [documents];\r\n    const { write = this.batch(), ctx } = options;\r\n    const operations = docs.map(async (value) => {\r\n      const id = (value[this.idKey] as string | undefined) || this.createId();\r\n      const data = await this.toFirestore(value, 'add');\r\n      if (this.storeId) data[this.idKey] = id;\r\n      const ref = this.getRef(id, options.params);\r\n      (write as WriteBatch).set(ref, data);\r\n      if (this.onCreate) {\r\n        await this.onCreate(data, { write, ctx });\r\n      }\r\n      return id;\r\n    });\r\n    const ids: string[] = await Promise.all(operations);\r\n    // If there is no atomic write provided\r\n    if (!options.write) {\r\n      await (write as WriteBatch).commit();\r\n    }\r\n    return Array.isArray(documents) ? ids : ids[0];\r\n  }\r\n\r\n  /**\r\n   * Remove one or several document from Firestore\r\n   * @param id A unique or list of id representing the document\r\n   * @param options options to write the document on firestore\r\n   */\r\n  async remove<T extends E>(id: string | string[], options: WriteOptions = {}) {\r\n    const { write = this.batch(), ctx } = options;\r\n    const ids: string[] = Array.isArray(id) ? id : [id];\r\n    const refs: DocumentReference<T>[] = [];\r\n    const operations = ids.map(async (docId) => {\r\n      const ref = this.getRef<T>(docId, options.params);\r\n      write.delete(ref);\r\n      if (this.onDelete) {\r\n        await this.onDelete(docId, { write, ctx });\r\n      }\r\n      refs.push(ref);\r\n    });\r\n    await Promise.all(operations);\r\n    // If there is no atomic write provided\r\n    if (!options.write) {\r\n      await (write as WriteBatch).commit();\r\n      if (this.memorize) this.clearCache(refs);\r\n    }\r\n  }\r\n\r\n  /** Remove all document of the collection */\r\n  async removeAll(options: WriteOptions = {}) {\r\n    const ref = options.params ? this.getRef(options.params) : this.getRef();\r\n    const snapshot = await getDocs(ref);\r\n    const ids = snapshot.docs.map((doc) => doc.id);\r\n    await this.remove(ids, options);\r\n    if (this.memorize) this.clearCache(ref);\r\n  }\r\n\r\n  /**\r\n   * Update one or several document in Firestore\r\n   */\r\n  update<T extends E>(entity: FireEntity<T> | FireEntity<T>[], options?: WriteOptions): Promise<void>;\r\n  update<T extends E>(id: string | string[], entityChanges: FireEntity<T>, options?: WriteOptions): Promise<void>;\r\n  update<T extends E>(\r\n    ids: string | string[],\r\n    stateFunction: UpdateCallback<T>,\r\n    options?: WriteOptions\r\n  ): Promise<Transaction[]>;\r\n  async update<T extends E>(\r\n    idsOrEntity: FireEntity<T> | FireEntity<T>[] | string | string[],\r\n    stateFnOrWrite?: UpdateCallback<T> | FireEntity<T> | WriteOptions,\r\n    options: WriteOptions = {}\r\n  ): Promise<void | Transaction[]> {\r\n    let ids: string[] = [];\r\n    let stateFunction: UpdateCallback<T> | undefined;\r\n    let getData: (docId: string) => FireEntity<T>;\r\n\r\n    const isEntity = (value: DocumentData | string): value is FireEntity<T> => {\r\n      return typeof value === 'object' && value[this.idKey];\r\n    };\r\n    const isEntityArray = (values: DocumentData | string[] | string): values is FireEntity<T>[] => {\r\n      return Array.isArray(values) && values.every((value) => isEntity(value));\r\n    };\r\n\r\n    if (isEntity(idsOrEntity)) {\r\n      ids = [idsOrEntity[this.idKey] as string];\r\n      getData = () => idsOrEntity;\r\n      options = (stateFnOrWrite as WriteOptions) || {};\r\n    } else if (isEntityArray(idsOrEntity)) {\r\n      const entityMap = new Map(\r\n        idsOrEntity.map((entity) => [entity[this.idKey] as string, entity])\r\n      );\r\n      ids = Array.from(entityMap.keys());\r\n      getData = (docId) => entityMap.get(docId)!;\r\n      options = (stateFnOrWrite as WriteOptions) || {};\r\n    } else if (typeof stateFnOrWrite === 'function') {\r\n      ids = Array.isArray(idsOrEntity) ? idsOrEntity : [idsOrEntity];\r\n      stateFunction = stateFnOrWrite as UpdateCallback<T>;\r\n    } else if (typeof stateFnOrWrite === 'object') {\r\n      ids = Array.isArray(idsOrEntity) ? idsOrEntity : [idsOrEntity];\r\n      getData = () => stateFnOrWrite as FireEntity<T>;\r\n    } else {\r\n      throw new Error('Passed parameters match none of the function signatures.');\r\n    }\r\n\r\n    const { ctx } = options;\r\n    if (!Array.isArray(ids) || !ids.length) {\r\n      return;\r\n    }\r\n\r\n    // If update depends on the entity, use transaction\r\n    if (stateFunction) {\r\n      let refs: DocumentReference<T>[] = [];\r\n      await runTransaction(this.db, async (tx) => {\r\n        refs = [];\r\n        const operations = ids.map(async (id) => {\r\n          const ref = this.getRef<T>(id, options.params);\r\n          refs.push(ref);\r\n          const snapshot = await tx.get(ref);\r\n          const doc = this.fromFirestore(snapshot);\r\n          if (doc && stateFunction) {\r\n            const data = await stateFunction(doc as T, tx);\r\n            const result = await this.toFirestore(data, 'update');\r\n            tx.update(ref, result);\r\n            if (this.onUpdate) {\r\n              await this.onUpdate(data, { write: tx, ctx });\r\n            }\r\n          }\r\n          return tx;\r\n        });\r\n        return Promise.all(operations);\r\n      });\r\n      if (this.memorize) this.clearCache(refs);\r\n    } else {\r\n      const { write = this.batch() } = options;\r\n      const refs: DocumentReference<T>[] = [];\r\n      const operations = ids.map(async (docId) => {\r\n        const doc = getData(docId);\r\n        if (!docId) {\r\n          throw new Error(`Document should have an unique id to be updated, but none was found in ${doc}`);\r\n        }\r\n        const ref = this.getRef<T>(docId, options.params);\r\n        refs.push(ref);\r\n        const data = await this.toFirestore(doc, 'update');\r\n        (write as WriteBatch).update(ref, data);\r\n        if (this.onUpdate) {\r\n          await this.onUpdate(doc, { write, ctx });\r\n        }\r\n      });\r\n      await Promise.all(operations);\r\n      // If there is no atomic write provided\r\n      if (!options.write) {\r\n        await (write as WriteBatch).commit();\r\n        if (this.memorize) this.clearCache(refs)\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { isPlatformServer } from \"@angular/common\";\r\nimport { collectionGroup, query } from \"firebase/firestore\";\r\nimport type { QueryDocumentSnapshot, DocumentSnapshot, Query, QueryConstraint } from 'firebase/firestore';\r\nimport { keepUnstableUntilFirst, isIdList, Params } from 'ngfire/core';\r\nimport { FireCollection } from \"./collection\";\r\nimport { toDate } from \"./utils\";\r\nimport { firstValueFrom, from, Observable, of } from \"rxjs\";\r\n\r\n\r\nexport abstract class FireSubCollection<E> extends FireCollection<E> {\r\n  abstract path: string;\r\n  protected pathKey = 'path';\r\n  \r\n  get groupId() {\r\n    return this.path.split('/').pop() as string;\r\n  }\r\n\r\n  /** Function triggered when getting data from firestore */\r\n  protected fromFirestore(snapshot: DocumentSnapshot<E> | QueryDocumentSnapshot<E>): E | undefined {\r\n    if (snapshot.exists()) {\r\n      return {\r\n        ...toDate(snapshot.data()),\r\n        [this.idKey]: snapshot.id,\r\n        [this.pathKey]: snapshot.ref.path\r\n      };\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  public getGroupRef<T extends E = E>(constraints?: QueryConstraint[]): Query<T> | undefined {\r\n    const group = collectionGroup(this.db, this.groupId) as Query<T>;\r\n    if (!arguments.length) return group;\r\n    if (!constraints) return;\r\n    return query(group, ...constraints);\r\n  }\r\n\r\n  /** Observable the content of group reference(s)  */\r\n  protected fromGroupRef<T extends E = E>(ref: Query<T>): Observable<T[]> {\r\n    if (isPlatformServer(this.platformId)) {\r\n      return this.zone.runOutsideAngular(() => from(this.getFromRef(ref))).pipe(\r\n        keepUnstableUntilFirst(this.zone),\r\n      );\r\n    }\r\n    return this.useCache(ref);\r\n  }\r\n\r\n\r\n  /** Return the current value of the path from Firestore */\r\n  public async getValue<T extends E = E>(ids?: string[], params?: Params): Promise<T[]>;\r\n  public async getValue<T extends E = E>(params: Params): Promise<T[]>;\r\n  public async getValue<T extends E = E>(query?: QueryConstraint[], params?: Params): Promise<T[]>;\r\n  public async getValue<T extends E = E>(id?: string | null, params?: Params): Promise<T | undefined>;\r\n  public async getValue<T extends E = E>(\r\n    idOrQuery?: null | string | string[] | QueryConstraint[] | Params,\r\n    params?: Params\r\n  ): Promise<T | T[] | undefined> {\r\n    // If array is empty\r\n    if (Array.isArray(idOrQuery) && !idOrQuery.length) return [];\r\n\r\n    // Group query\r\n    const isEmpty = arguments.length === 0;\r\n    const isGroupQuery = arguments.length === 1 && Array.isArray(idOrQuery) && !isIdList(idOrQuery);\r\n\r\n    // Collection Query\r\n    const ref = (isEmpty || isGroupQuery)\r\n      ? this.getGroupRef<T>(...arguments)\r\n      : this.getRef<T>(...arguments);\r\n    if (!ref) return;\r\n    return this.getFromRef(ref);\r\n  }\r\n\r\n  /** Clear cache and get the latest value into the cache */\r\n  public async reload<T extends E = E>(ids?: string[], params?: Params): Promise<T[]>;\r\n  public async reload<T extends E = E>(params: Params): Promise<T[]>;\r\n  public async reload<T extends E = E>(query?: QueryConstraint[], params?: Params): Promise<T[]>;\r\n  public async reload<T extends E = E>(id?: string | null, params?: Params): Promise<T | undefined>;\r\n  public async reload<T extends E = E>(\r\n    idOrQuery?: null | string | string[] | QueryConstraint[] | Params,\r\n    params?: Params\r\n  ): Promise<T | T[] | undefined> {\r\n    const isEmpty = arguments.length === 0;\r\n    const isGroupQuery = arguments.length === 1 && Array.isArray(idOrQuery) && !isIdList(idOrQuery);\r\n    const ref = (isEmpty || isGroupQuery)\r\n      ? this.getGroupRef(...arguments)\r\n      : this.getRef(...arguments);\r\n    if (!ref) return;\r\n    if (this.memorize) {\r\n      Array.isArray(ref)\r\n        ? ref.forEach(r => this.clearCache(r))\r\n        : this.clearCache(ref);\r\n    }\r\n    return this.load(...arguments);\r\n  }\r\n  \r\n\r\n  /** Get the last content from the app (if value has been cached, it won't do a server request)  */\r\n  public load<T extends E = E>(ids?: string[], params?: Params): Promise<T[]>;\r\n  public load<T extends E = E>(params: Params): Promise<T[]>;\r\n  public load<T extends E = E>(query?: QueryConstraint[], params?: Params): Promise<T[]>;\r\n  public load<T extends E = E>(id?: string, params?: Params): Promise<T | undefined>;\r\n  public load<T extends E = E>(\r\n    idOrQuery?: string | string[] | QueryConstraint[] | Params,\r\n    params?: Params\r\n  ): Promise<T | T[] | undefined>;\r\n  public load<T extends E = E>(): Promise<T | T[] | undefined> {\r\n    return firstValueFrom(this.valueChanges(...arguments));\r\n  }\r\n\r\n  /** Return the current value of the path from Firestore */\r\n  public valueChanges<T extends E = E>(ids?: string[], params?: Params): Observable<T[]>;\r\n  public valueChanges<T extends E = E>(params: Params): Observable<T[]>;\r\n  public valueChanges<T extends E = E>(query?: QueryConstraint[], params?: Params): Observable<T[]>;\r\n  public valueChanges<T extends E = E>(id?: string, params?: Params): Observable<T | undefined>;\r\n  public valueChanges<T extends E = E>(\r\n    idOrQuery?: string | string[] | QueryConstraint[] | Params,\r\n    params?: Params\r\n  ): Observable<T | T[] | undefined>;\r\n  public valueChanges<T extends E = E>(\r\n    idOrQuery?: string | string[] | QueryConstraint[] | Params,\r\n    params?: Params\r\n  ): Observable<T | T[] | undefined> {\r\n    // If array is empty\r\n    if (Array.isArray(idOrQuery) && !idOrQuery.length) return of([]);\r\n    \r\n    // Check if group query\r\n    const isEmpty = arguments.length === 0;\r\n    const isGroupQuery = arguments.length === 1 && Array.isArray(idOrQuery) && !isIdList(idOrQuery);\r\n\r\n    // Group or Collection Query\r\n    const ref = (isEmpty || isGroupQuery)\r\n      ? this.getGroupRef<T>(...arguments)\r\n      : this.getRef<T>(...arguments);\r\n\r\n    if (!ref) return of(undefined);\r\n    return this.fromRef(ref);\r\n  }\r\n\r\n}","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}