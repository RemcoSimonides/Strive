{"version":3,"file":"ngfire-database.mjs","sources":["../../../../libs/ngfire/database/src/operators.ts","../../../../libs/ngfire/database/src/tokens.ts","../../../../libs/ngfire/database/src/database.ts","../../../../libs/ngfire/database/src/utils.ts","../../../../libs/ngfire/database/src/list.ts","../../../../libs/ngfire/database/src/ngfire-database.ts"],"sourcesContent":["import {Observable} from 'rxjs';\r\nimport {delay} from 'rxjs/operators';\r\nimport {DataSnapshot, onValue} from 'firebase/database';\r\nimport type {Query} from 'firebase/database';\r\n\r\n/**\r\n * Create an observable from a Database Reference or Database Query.\r\n * @param query Database Reference\r\n */\r\nexport function fromQuery(query: Query): Observable<DataSnapshot> {\r\n  return new Observable<DataSnapshot>((subscriber) => {\r\n    const unsubscribe = onValue(\r\n      query,\r\n      (snapshot) => subscriber.next(snapshot),\r\n      subscriber.error.bind(subscriber),\r\n    );\r\n    return { unsubscribe };\r\n  }).pipe(\r\n      // Ensures subscribe on observable is async. This handles\r\n      // a quirk in the SDK where on/once callbacks can happen\r\n      // synchronously.\r\n      delay(0)\r\n  );\r\n}","import { inject, InjectionToken } from \"@angular/core\";\r\nimport { Database, getDatabase } from \"firebase/database\";\r\nimport { FIREBASE_APP } from \"ngfire/app\";\r\nimport { DB_URL, getConfig } from \"ngfire/tokens\";\r\n\r\n\r\nexport const DATABASE = new InjectionToken<Database>('Database instance', {\r\n  providedIn: 'root',\r\n  factory: () => {\r\n    const config = getConfig();\r\n    const app = inject(FIREBASE_APP);\r\n    const url = inject(DB_URL, { optional: true });\r\n    if (config.database) {\r\n      return config.database(app, url ?? undefined)\r\n    } else {\r\n      return getDatabase(app, url ?? undefined);\r\n    }\r\n  },\r\n});\r\n","import { inject, Injectable, Injector } from \"@angular/core\";\r\nimport { QueryConstraint, ref as dbRef, remove, set, update, query as queryWithConstraints, DataSnapshot } from 'firebase/database';\r\nimport type { DatabaseReference, Query } from 'firebase/database';\r\nimport { Observable } from \"rxjs\";\r\nimport { Params, assertPath, pathWithParams } from \"ngfire/core\";\r\nimport { fromQuery } from \"./operators\";\r\nimport { DATABASE } from \"./tokens\";\r\n\r\n\r\nexport function isContraintList(idsOrQuery: any[]): idsOrQuery is QueryConstraint[] {\r\n  return idsOrQuery.every(query => query instanceof QueryConstraint);\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class FireDatabase {\r\n  protected injector = inject(Injector);\r\n  protected memory = new Map<Query, Observable<DataSnapshot>>();\r\n\r\n  get db() {\r\n    return this.injector.get(DATABASE);\r\n  }\r\n\r\n  /** Get the reference of the document, collection or query */\r\n  public getRef(path: string, params?: Params): DatabaseReference;\r\n  public getRef(paths: string[], params?: Params): DatabaseReference[];\r\n  public getRef(path: string, constraints: QueryConstraint[], params?: Params): Query;\r\n  public getRef(paths: string[], constraints: QueryConstraint[], params?: Params): Query;\r\n  // overload used internally when looping over paths array\r\n  public getRef(paths: string, constraints?: Params | QueryConstraint[], params?: Params): Query | DatabaseReference;\r\n  public getRef(\r\n    paths: string | string[],\r\n    paramsOrConstraints?: Params | QueryConstraint[],\r\n    params?: Params\r\n  ): undefined | Query | Query[] | DatabaseReference | DatabaseReference[] {\r\n    if (!arguments.length || !paths) return undefined;\r\n    const hasContraints = Array.isArray(paramsOrConstraints);\r\n\r\n    if (Array.isArray(paths)) {\r\n      return paths.map((path) => this.getRef(path, paramsOrConstraints, params));\r\n    }\r\n\r\n    if (hasContraints) {\r\n      const path = pathWithParams(paths, params);\r\n      assertPath(path);\r\n      const ref = dbRef(this.db, path);\r\n      return queryWithConstraints(ref, ...paramsOrConstraints);\r\n    } else {\r\n      const path = pathWithParams(paths, paramsOrConstraints);\r\n      assertPath(path);\r\n      return dbRef(this.db, path);\r\n    }\r\n  }\r\n\r\n  fromQuery(query: Query) {\r\n    let existing: Observable<DataSnapshot> | null = null;\r\n    for (const [key, value] of this.memory.entries()) {\r\n      if (query.isEqual(key)) {\r\n        existing = value;\r\n        break;\r\n      }\r\n    }\r\n    if (existing) return existing;\r\n    this.memory.set(query, fromQuery(query));\r\n    return this.memory.get(query) as Observable<DataSnapshot>;\r\n  }\r\n\r\n  create<T>(path: string, content: T) {\r\n    return set(this.getRef(path), content);\r\n  }\r\n\r\n  update<T>(path: string, value: Partial<T>) {\r\n    const ref = this.getRef(path);\r\n    return update(ref, value);\r\n  }\r\n\r\n  remove(path: string) {\r\n    const ref = this.getRef(path);\r\n    return remove(ref);\r\n  }\r\n}\r\n","/** Recursively all Date into Timestamp */\r\nexport function fromDate<D>(target: D): D {\r\n  if (typeof target !== 'object') return target;\r\n  for (const key in target) {\r\n    const value = target[key];\r\n    if (!value || typeof value !== 'object') continue;\r\n    if (value instanceof Date) {\r\n      target[key] = value.getTime() as any;\r\n      continue;\r\n    }\r\n    fromDate(value)\r\n  }\r\n  return target;\r\n}\r\n\r\n/** Recursively all Date into Timestamp */\r\nexport function toDate<D>(target: D, dateKeys: string[], path: string = ''): D {\r\n  if (typeof target !== 'object') return target;\r\n  for (const key in target) {\r\n    const value = target[key];\r\n    const deepKey = `${path}.${key}`;\r\n    if (dateKeys.includes(deepKey)) {\r\n      if (typeof value !== 'number') throw new Error(`Date key \"${deepKey}\" is not a number. Got ${value}`);\r\n      target[key] = new Date(value) as any;\r\n      continue;\r\n    }\r\n    if (!value || typeof value !== 'object') continue;\r\n    toDate(value, dateKeys, deepKey);\r\n  }\r\n  return target;\r\n}\r\n\r\n\r\n","import { inject } from \"@angular/core\";\r\nimport { DatabaseReference, DataSnapshot, Query, QueryConstraint, set } from \"firebase/database\";\r\nimport { push, get, remove, update } from \"firebase/database\";\r\nimport { combineLatest, Observable, of } from \"rxjs\";\r\nimport { map } from \"rxjs/operators\";\r\nimport { ExtractDeepKeys, Params, exist, isIdList, pathWithParams } from \"ngfire/core\";\r\nimport { FireDatabase } from \"./database\";\r\nimport { serverTimestamp } from 'firebase/database';\r\nimport { fromDate, toDate } from \"./utils\";\r\n\r\ninterface ToDataOptions {\r\n  isList: boolean;\r\n}\r\n\r\nfunction isListQuery(query?: string | string[] | QueryConstraint[] | Params) {\r\n  if (typeof query === 'string') return false;\r\n  if (Array.isArray(query) && isIdList(query)) return false;\r\n  return true;\r\n}\r\n\r\n\r\nfunction toKey(value: unknown) {\r\n  if (typeof value === 'string') return value;\r\n  if (typeof value === 'number') return value.toString();\r\n  throw new Error('Key of list should either be a string or a number'); \r\n}\r\n\r\nexport function addMeta(doc: DocumentMeta, actionType: 'add' | 'update') {\r\n  const _meta: DocumentMeta['_meta'] = doc['_meta'] ?? {};\r\n  if (actionType === 'add') _meta.createdAt = serverTimestamp() as Date;\r\n  if (actionType === 'update') _meta.modifiedAt = serverTimestamp() as Date;\r\n  doc._meta = _meta;\r\n}\r\n\r\nexport interface DocumentMeta {\r\n  _meta: {\r\n    createdAt?: Date;\r\n    modifiedAt?: Date;\r\n  }\r\n}\r\n\r\nexport abstract class FireList<E> {\r\n  protected fireDB = inject(FireDatabase);\r\n  protected abstract readonly path: string;\r\n  protected abstract dateKeys: ExtractDeepKeys<E, Date>[];\r\n  protected idKey?: keyof E;\r\n  protected pathKey?: keyof E;\r\n\r\n  protected fromDatabase(snap: DataSnapshot): E | null {\r\n    if (!snap.exists()) return null;\r\n    const value = snap.val();\r\n    \r\n    const dateKeys = [...this.dateKeys, '_meta.createdAt', '_meta.modifiedAt'];\r\n    if (!value || typeof value !== 'object') return toDate(value, dateKeys);\r\n    if (this.idKey) value[this.idKey] = snap.key;\r\n    if (this.pathKey) value[this.pathKey] = snap.ref.toString();\r\n    return toDate(value, dateKeys);\r\n  }\r\n\r\n  protected toDatabase(doc: Partial<E>, actionType: 'add' | 'update') {\r\n    return fromDate(doc); \r\n  }\r\n\r\n  private toData<T extends E = E>(snaps: DataSnapshot | null, options: ToDataOptions): T | null\r\n  private toData<T extends E = E>(snaps: DataSnapshot[], options: ToDataOptions): T[]\r\n  private toData<T extends E = E>(snaps: DataSnapshot | DataSnapshot[] | null, options: ToDataOptions): T | T[] | null\r\n  private toData<T extends E = E>(snaps: DataSnapshot | DataSnapshot[] | null, options: ToDataOptions): T | T[] | null {\r\n    if (!snaps) return null;\r\n    if (Array.isArray(snaps)) return snaps.map(snap => this.toData<T>(snap, { isList: false })).filter(exist);\r\n    if (!options.isList) return this.fromDatabase(snaps) as any;\r\n    const docs: (T | null)[] = [];\r\n    // forEach cancels when return value is \"true\". So I return \"false\"\r\n    snaps.forEach(snap => !docs.push(this.fromDatabase(snap) as any));\r\n    return docs.filter(exist);\r\n  }\r\n\r\n  getPath(key?: string | Params, params?: Params) {\r\n    if (typeof key === 'string') return pathWithParams(`${this.path}/${key}`, params);\r\n    return pathWithParams(this.path, key);\r\n  }\r\n\r\n  getRef(): DatabaseReference\r\n  getRef(params: Params): DatabaseReference\r\n  getRef(key: string, params?: Params): DatabaseReference\r\n  getRef(keys: string[], params?: Params): DatabaseReference[]\r\n  getRef(constraints: QueryConstraint[], params?: Params): Query\r\n  // Use internally\r\n  getRef(query?: string | string[] | QueryConstraint[] | Params, params?: Params): DatabaseReference | DatabaseReference[] | Query\r\n  getRef(query?: string | string[] | QueryConstraint[] | Params, params?: Params) {\r\n    // String or Params (getPath return base path is query is Params)\r\n    if (!Array.isArray(query)) return this.fireDB.getRef(this.getPath(query), params);\r\n    \r\n    return isIdList(query)\r\n      // key list\r\n      ? this.fireDB.getRef(query.map(key => this.getPath(key)), params)\r\n      // query constraints\r\n      : this.fireDB.getRef(this.getPath(), query, params);\r\n  }\r\n\r\n  private fromQuery(): Observable<DataSnapshot>\r\n  private fromQuery(params: Params): Observable<DataSnapshot>\r\n  private fromQuery(key: string, params?: Params): Observable<DataSnapshot> | Observable<null>\r\n  private fromQuery(keys: string[], params?: Params): Observable<DataSnapshot[]>\r\n  private fromQuery(constraints: QueryConstraint[], params?: Params): Observable<DataSnapshot[]>\r\n  // Use internally\r\n  private fromQuery(query?: string | string[] | QueryConstraint[] | Params, params?: Params): Observable<DataSnapshot | DataSnapshot[] | null>\r\n  private fromQuery(query?: string | string[] | QueryConstraint[] | Params, params?: Params): Observable<DataSnapshot | DataSnapshot[] | null> {\r\n    const refs = this.getRef(query, params);\r\n    if (!Array.isArray(refs)) return this.fireDB.fromQuery(refs);\r\n    const obs = refs.map(ref => this.fireDB.fromQuery(ref));\r\n    return combineLatest(obs);\r\n  }\r\n\r\n  private getQuery(): Promise<DataSnapshot>\r\n  private getQuery(params: Params): Promise<DataSnapshot>\r\n  private getQuery(key: string, params?: Params): Promise<DataSnapshot> | Promise<null>\r\n  private getQuery(keys: string[], params?: Params): Promise<DataSnapshot[]>\r\n  private getQuery(constraints: QueryConstraint[], params?: Params): Promise<DataSnapshot[]>\r\n  // Use internally\r\n  private getQuery(query?: string | string[] | QueryConstraint[] | Params, params?: Params): Promise<DataSnapshot | DataSnapshot[] | null>\r\n  private getQuery(query?: string | string[] | QueryConstraint[] | Params, params?: Params): Promise<DataSnapshot | DataSnapshot[] | null> {\r\n    const refs = this.getRef(query, params);\r\n    if (!Array.isArray(refs)) return get(refs);\r\n    const promises = refs.map(ref => get(ref));\r\n    return Promise.all(promises);\r\n  }\r\n\r\n  valueChanges<T extends E = E>(): Observable<T[]>\r\n  valueChanges<T extends E = E>(params: Params): Observable<T[]>\r\n  valueChanges<T extends E = E>(key: string, params?: Params): Observable<T | null>\r\n  valueChanges<T extends E = E>(keys: string[], params?: Params): Observable<T[]>\r\n  valueChanges<T extends E = E>(constraints: QueryConstraint[], params?: Params): Observable<T[]>\r\n  valueChanges<T extends E = E>(query?: string | string[] | QueryConstraint[] | Params, params?: Params): Observable<T | T[] | null> {\r\n    if (arguments.length && !query) return of(null);\r\n    return this.fromQuery(query, params).pipe(\r\n      map(snap => this.toData(snap, { isList: isListQuery(query) })),\r\n    );\r\n  }\r\n\r\n  getValue<T extends E = E>(): Promise<T[]>\r\n  getValue<T extends E = E>(params: Params): Promise<T[]>\r\n  getValue<T extends E = E>(key: string, params?: Params): Promise<T | null>\r\n  getValue<T extends E = E>(keys: string[], params?: Params): Promise<T[]>\r\n  getValue<T extends E = E>(constraints: QueryConstraint[], params?: Params): Promise<T[]>\r\n  async getValue<T extends E = E>(query?: string | string[] | QueryConstraint[] | Params, params?: Params): Promise<T | T[] | null> {\r\n    if (arguments.length && !query) return Promise.resolve(null);\r\n    const snap = await this.getQuery(query, params)\r\n    return this.toData<T>(snap, { isList: isListQuery(query) });\r\n  }\r\n\r\n  add<T extends E>(value: Partial<T>, params?: Params) {\r\n    const doc = this.toDatabase(value, 'add');\r\n    if (this.idKey && doc[this.idKey]) {\r\n      const key = toKey(doc[this.idKey]);\r\n      const ref = this.getRef(key, params);\r\n      return set(ref, doc);\r\n    }\r\n    const listRef = params ? this.getRef(params) : this.getRef();\r\n    return push(listRef, doc);\r\n  }\r\n\r\n  update<T extends E>(key: string, value: Partial<T>, params?: Params) {\r\n    const doc = this.toDatabase(value, 'update');\r\n    const path = this.getRef(key, params);\r\n    return update(path, doc);\r\n  }\r\n\r\n  remove(key: string, params?: Params) {\r\n    const ref = this.getRef(key, params);\r\n    return remove(ref);\r\n  }\r\n\r\n  /** We use a separated method to avoid mistakes */\r\n  removeAll(params?: Params) {\r\n    const ref = params ? this.getRef(params) : this.getRef();\r\n    return remove(ref);\r\n  }\r\n}","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["ref","dbRef","queryWithConstraints"],"mappings":"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"}