{"version":3,"file":"ngfire-storage.mjs","sources":["../../../../libs/ngfire/storage/src/operators.ts","../../../../libs/ngfire/storage/src/tokens.ts","../../../../libs/ngfire/storage/src/service.ts","../../../../libs/ngfire/storage/src/ngfire-storage.ts"],"sourcesContent":["import {Observable} from 'rxjs';\r\nimport {debounceTime, map} from 'rxjs/operators';\r\nimport type { UploadTaskSnapshot, UploadTask } from 'firebase/storage';\r\n\r\nexport function fromTask(task: UploadTask): Observable<UploadTaskSnapshot> {\r\n  return new Observable<UploadTaskSnapshot>((subscriber) => {\r\n    const progress = (snap: UploadTaskSnapshot): void => subscriber.next(snap);\r\n    const error = (e: Error): void => subscriber.error(e);\r\n    const complete = (): void => subscriber.complete();\r\n    // emit the current state of the task\r\n    progress(task.snapshot);\r\n    // emit progression of the task\r\n    const unsubscribeFromOnStateChanged = task.on('state_changed', progress);\r\n    // use the promise form of task, to get the last success snapshot\r\n    task.then(\r\n        (snapshot) => {\r\n          progress(snapshot);\r\n          setTimeout(() => complete(), 0);\r\n        },\r\n        (e) => {\r\n          progress(task.snapshot);\r\n          setTimeout(() => error(e), 0);\r\n        },\r\n    );\r\n    // the unsubscribe method returns by storage isn't typed in the\r\n    // way rxjs expects, Function vs () => void, so wrap it\r\n    return function unsubscribe() {\r\n      unsubscribeFromOnStateChanged();\r\n    };\r\n  }).pipe(\r\n      // since we're emitting first the current snapshot and then progression\r\n      // it's possible that we could double fire synchronously; namely when in\r\n      // a terminal state (success, error, canceled). Debounce to address.\r\n      debounceTime(0),\r\n  );\r\n}\r\n\r\nexport interface PercentageSnapshot {\r\n  progress: number;\r\n  snapshot: UploadTaskSnapshot;\r\n}\r\nexport function percentage(task: UploadTask): Observable<PercentageSnapshot> {\r\n  return fromTask(task).pipe(\r\n    map((snapshot) => ({\r\n      progress: (snapshot.bytesTransferred / snapshot.totalBytes) * 100,\r\n      snapshot,\r\n    })),\r\n  );\r\n}","import { inject, InjectionToken } from \"@angular/core\";\r\nimport { FirebaseStorage, getStorage } from \"firebase/storage\";\r\nimport { FIREBASE_APP } from \"ngfire/app\";\r\nimport { getConfig, STORAGE_BUCKET } from \"ngfire/tokens\";\r\n\r\n\r\nexport const FIRE_STORAGE = new InjectionToken<FirebaseStorage>('Firebase Storage', {\r\n  providedIn: 'root',\r\n  factory: () => {\r\n    const config = getConfig();\r\n    const app = inject(FIREBASE_APP);\r\n    const bucket = inject(STORAGE_BUCKET, { optional: true });\r\n    if (config.storage) {\r\n      return config.storage(app, bucket ?? undefined);\r\n    } else {\r\n      return getStorage(app, bucket ?? undefined);\r\n    }\r\n  },\r\n});\r\n","import { inject, Injectable, Injector } from \"@angular/core\";\r\nimport { ref, uploadBytesResumable, UploadMetadata } from \"firebase/storage\";\r\nimport { FIRE_STORAGE } from \"./tokens\";\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class FireStorage {\r\n  private injector = inject(Injector);\r\n  protected bucket?: string;\r\n\r\n  protected get storage() {\r\n    return this.injector.get(FIRE_STORAGE);\r\n  }\r\n\r\n  ref(url: string) {\r\n    return ref(this.storage, url);\r\n  }\r\n\r\n  upload(url: string, bytes: Blob | Uint8Array | ArrayBuffer, metadata?: UploadMetadata) {\r\n    const ref = this.ref(url);\r\n    return uploadBytesResumable(ref, bytes, metadata);\r\n  }\r\n}","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":";;;;;;;;AAIM,SAAU,QAAQ,CAAC,IAAgB,EAAA;AACvC,IAAA,OAAO,IAAI,UAAU,CAAqB,CAAC,UAAU,KAAI;AACvD,QAAA,MAAM,QAAQ,GAAG,CAAC,IAAwB,KAAW,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC;AAC1E,QAAA,MAAM,KAAK,GAAG,CAAC,CAAQ,KAAW,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;QACrD,MAAM,QAAQ,GAAG,MAAY,UAAU,CAAC,QAAQ,EAAE;;AAElD,QAAA,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC;;QAEvB,MAAM,6BAA6B,GAAG,IAAI,CAAC,EAAE,CAAC,eAAe,EAAE,QAAQ,CAAC;;AAExE,QAAA,IAAI,CAAC,IAAI,CACL,CAAC,QAAQ,KAAI;YACX,QAAQ,CAAC,QAAQ,CAAC;YAClB,UAAU,CAAC,MAAM,QAAQ,EAAE,EAAE,CAAC,CAAC;AACjC,SAAC,EACD,CAAC,CAAC,KAAI;AACJ,YAAA,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC;YACvB,UAAU,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;AAC/B,SAAC,CACJ;;;AAGD,QAAA,OAAO,SAAS,WAAW,GAAA;AACzB,YAAA,6BAA6B,EAAE;AACjC,SAAC;KACF,CAAC,CAAC,IAAI;;;;AAIH,IAAA,YAAY,CAAC,CAAC,CAAC,CAClB;AACH;AAMM,SAAU,UAAU,CAAC,IAAgB,EAAA;AACzC,IAAA,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAC,IAAI,CACxB,GAAG,CAAC,CAAC,QAAQ,MAAM;QACjB,QAAQ,EAAE,CAAC,QAAQ,CAAC,gBAAgB,GAAG,QAAQ,CAAC,UAAU,IAAI,GAAG;QACjE,QAAQ;KACT,CAAC,CAAC,CACJ;AACH;;MC1Ca,YAAY,GAAG,IAAI,cAAc,CAAkB,kBAAkB,EAAE;AAClF,IAAA,UAAU,EAAE,MAAM;IAClB,OAAO,EAAE,MAAK;AACZ,QAAA,MAAM,MAAM,GAAG,SAAS,EAAE;AAC1B,QAAA,MAAM,GAAG,GAAG,MAAM,CAAC,YAAY,CAAC;AAChC,QAAA,MAAM,MAAM,GAAG,MAAM,CAAC,cAAc,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC;AACzD,QAAA,IAAI,MAAM,CAAC,OAAO,EAAE;YAClB,OAAO,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,MAAM,IAAI,SAAS,CAAC;;aAC1C;YACL,OAAO,UAAU,CAAC,GAAG,EAAE,MAAM,IAAI,SAAS,CAAC;;KAE9C;AACF,CAAA;;MCbY,WAAW,CAAA;AACd,IAAA,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC;AACzB,IAAA,MAAM;AAEhB,IAAA,IAAc,OAAO,GAAA;QACnB,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,YAAY,CAAC;;AAGxC,IAAA,GAAG,CAAC,GAAW,EAAA;QACb,OAAO,GAAG,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC;;AAG/B,IAAA,MAAM,CAAC,GAAW,EAAE,KAAsC,EAAE,QAAyB,EAAA;QACnF,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;QACzB,OAAO,oBAAoB,CAAC,GAAG,EAAE,KAAK,EAAE,QAAQ,CAAC;;uGAdxC,WAAW,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,UAAA,EAAA,CAAA;AAAX,IAAA,OAAA,KAAA,GAAA,EAAA,CAAA,qBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,WAAW,cADE,MAAM,EAAA,CAAA;;2FACnB,WAAW,EAAA,UAAA,EAAA,CAAA;kBADvB,UAAU;mBAAC,EAAE,UAAU,EAAE,MAAM,EAAE;;;ACJlC;;AAEG;;;;"}