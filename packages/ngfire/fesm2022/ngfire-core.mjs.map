{"version":3,"file":"ngfire-core.mjs","sources":["../../../../libs/ngfire/core/src/operators.ts","../../../../libs/ngfire/core/src/utils.ts","../../../../libs/ngfire/core/src/zone.ts","../../../../libs/ngfire/core/src/ngfire-core.ts"],"sourcesContent":["import {\r\n  combineLatest,\r\n  Observable,\r\n  OperatorFunction,\r\n  of,\r\n  from,\r\n  ReplaySubject,\r\n  timer,\r\n} from 'rxjs';\r\nimport { debounceTime, map, startWith, switchMap, tap, share } from 'rxjs/operators';\r\n\r\n\r\nexport function shareWithDelay<T>(delay: number = 100) {\r\n  return share<T>({\r\n    connector: () => new ReplaySubject(1),\r\n    resetOnRefCountZero: () => delay ? timer(delay) : of(true),\r\n    resetOnError: true,\r\n    resetOnComplete: false,\r\n  })\r\n}\r\n\r\n\r\ntype QueryMap<T> = Record<string, (data: Entity<T>) => any>\r\ntype Entity<T> = T extends Array<infer I> ? I : T;\r\ntype GetSnapshot<F extends (...data: any) => any> = \r\n  F extends (...data: any) => Observable<infer I> ? I\r\n  : F extends (...data: any) => Promise<infer J> ? J\r\n  : ReturnType<F>;\r\ntype Join<T, Query extends QueryMap<T>> = T & { [key in keyof Query]?: GetSnapshot<Query[key]> };\r\ntype Jointure<T, Query extends QueryMap<any>> = T extends Array<infer I>\r\n  ? Join<I, Query>[]\r\n  : Join<T, Query>;\r\n\r\ninterface JoinWithOptions {\r\n  /** If set to false, the subqueries will be filled with undefined and hydrated as they come through */\r\n  shouldAwait?: boolean;\r\n  /** Used to not trigger change detection too often */\r\n  debounceTime?: number;\r\n}\r\n\r\n/**\r\n * Operator that join the source with sub queries.\r\n * There are two stategies : \r\n * 1. `shouldAwait: true`: Await all subqueries to emit once before emitting a next value\r\n * 2. `shouldAwait: false`: Emit the source and hydrate it with the subqueries along the way\r\n * @example\r\n * ```typescript\r\n * of({ docUrl: '...' }).valueChanges().pipe(\r\n *   joinWith({\r\n *     doc: source => fetch(docUrl).then(res => res.json()),\r\n *   }, { shouldAwait: true })\r\n * ).subscribe(res => console.log(res.subQuery))\r\n * ```\r\n * @param queries A map of subqueries to apply. Each query can return a static value, Promise or Observable\r\n * @param options Strategy to apply on the joinWith\r\n */\r\nexport function joinWith<T, Query extends QueryMap<T>>(queries: Query, options: JoinWithOptions = {}): OperatorFunction<T, Jointure<T, Query>> {\r\n  const shouldAwait = options.shouldAwait ?? true;\r\n  const debounce = options.debounceTime ?? 100;\r\n  const runQuery = (entity: Entity<T>) => {\r\n    const obs = [];\r\n    for (const key in queries) {\r\n      // Transform return value into an observable\r\n      let result: any = queries[key](entity);\r\n      if (!(result instanceof Observable)) {\r\n        if (result instanceof Promise) {\r\n          result = from(result);\r\n        } else {\r\n          result = of(result);\r\n        }\r\n      }\r\n      // Hydrate the entity with the data\r\n      let observe: Observable<any>;\r\n      if (shouldAwait) {\r\n        observe = result.pipe(\r\n          tap(result => (entity as any)[key] = result),\r\n        );\r\n      } else {\r\n        observe = result.pipe(\r\n          startWith(undefined),\r\n          tap(result => (entity as any)[key] = result),\r\n        );\r\n      }\r\n      obs.push(observe);\r\n    }\r\n    if (!obs.length) return of(entity);\r\n    return combineLatest(obs).pipe(\r\n      map(() => {\r\n        if (!entity) return entity;\r\n        return JSON.parse(JSON.stringify(entity), jsonDateReviver) as any;\r\n      }),\r\n    );\r\n  }\r\n\r\n  return switchMap((data: T) => {\r\n    if (Array.isArray(data)) {\r\n      if (!data.length) return of([]);\r\n      return combineLatest(data.map(runQuery)).pipe(debounceTime(debounce));\r\n    }\r\n    return runQuery(data as Entity<T>);\r\n  });\r\n}\r\n\r\nfunction jsonDateReviver(_: unknown, value: any) {\r\n  if (!value) return value;\r\n\r\n  const dateFormat = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{1,}|)Z$/;\r\n  if (typeof value === 'string' && dateFormat.test(value)) return new Date(value);\r\n  if (\r\n    typeof value === 'object' &&\r\n    Object.keys(value).length === 2 &&\r\n    ['nanoseconds', 'seconds'].every((k) => k in value)\r\n  )\r\n    return new Date(((value.nanoseconds * 1) ^ -6) + value.seconds * 1000);\r\n\r\n  return value;\r\n}\r\n","import type { CollectionReference, DocumentReference, Query } from \"firebase/firestore\";\r\nimport { Params } from \"./types\";\r\n\r\nexport function exist<D>(doc: D | undefined | null): doc is D {\r\n  return doc !== undefined && doc !== null;\r\n}\r\n\r\nexport function isNotUndefined<D>(doc: D | undefined): doc is D {\r\n  return doc !== undefined;\r\n}\r\n\r\n\r\n//////////\r\n// PATH //\r\n//////////\r\nexport function isDocPath(path: string) {\r\n  return path.split('/').length % 2 === 0;\r\n} \r\n\r\n// Check if a string is a full path\r\nexport function isPathRef(path?: any): path is string {\r\n  return !!((typeof path === \"string\") && (path.split('/').length > 1) && !path.includes(':'));\r\n}\r\n\r\nexport function isIdList(idsOrQuery: any[]): idsOrQuery is string[] {\r\n  return (idsOrQuery as any[]).every(id => typeof id === 'string');\r\n}\r\n\r\n/** Get the params from a path */\r\nexport function getPathParams(path: string) {\r\n  return path\r\n    .split('/')\r\n    .filter((segment) => segment.charAt(0) === ':')\r\n    .map((segment) => segment.substring(1));\r\n}\r\n\r\n\r\nexport function assertPath(path: string) {\r\n  for (const segment of path.split('/')) {\r\n    if (segment.charAt(0) === ':') {\r\n      const key = segment.substring(1);\r\n      throw new Error(`Required parameter ${key} from ${path} has not been provided`);\r\n    }\r\n  }\r\n}\r\n\r\nexport function assertCollection(path: string) {\r\n  if (isDocPath(path)) {\r\n    throw new Error(`Expected collection path but got: ${path}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Transform a path based on the params\r\n * @param path The path with params starting with \"/:\"\r\n * @param params A map of id params\r\n * @example pathWithParams('movies/:movieId/stakeholder/:shId', { movieId, shId })\r\n */\r\nexport function pathWithParams(path: string, params?: Params): string {\r\n  if (!params) return path;\r\n  if (!path.includes(':')) return path;\r\n  return path\r\n    .split('/')\r\n    .map((segment) => {\r\n      if (segment.charAt(0) === ':') {\r\n        const key = segment.substr(1);\r\n        return params[key] || segment;\r\n      } else {\r\n        return segment;\r\n      }\r\n    })\r\n    .join('/');\r\n}\r\n\r\n////////////////\r\n// REFERENCES //\r\n////////////////\r\nexport function isQuery<E>(ref: CollectionReference<E> | DocumentReference<E> | Query<E>): ref is Query<E> {\r\n  return ref.type === 'query';\r\n}\r\nexport function isCollectionRef<E>(ref: CollectionReference<E> | DocumentReference<E> | Query<E>): ref is CollectionReference<E> {\r\n  return ref.type === 'collection';\r\n}","import { NgZone } from \"@angular/core\";\r\nimport { SchedulerAction, SchedulerLike, queueScheduler, Subscription, Observable, Subscriber, TeardownLogic, Operator, asyncScheduler } from \"rxjs\";\r\nimport { observeOn, subscribeOn, tap } from \"rxjs/operators\";\r\n\r\nexport class ɵZoneScheduler implements SchedulerLike {\r\n  constructor(private zone: any, private delegate: SchedulerLike = queueScheduler) {}\r\n\r\n  now() {\r\n    return this.delegate.now();\r\n  }\r\n\r\n  schedule(work: (this: SchedulerAction<any>, state?: any) => void, delay?: number, state?: any): Subscription {\r\n    const targetZone = this.zone;\r\n    // Wrap the specified work function to make sure that if nested scheduling takes place the\r\n    // work is executed in the correct zone\r\n    const workInZone = function(this: SchedulerAction<any>, state: any) {\r\n      targetZone.runGuarded(() => {\r\n        work.apply(this, [state]);\r\n      });\r\n    };\r\n\r\n    // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\r\n    // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\r\n    // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\r\n    return this.delegate.schedule(workInZone, delay, state);\r\n  }\r\n}\r\n\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-empty-function\r\nfunction noop() {}\r\ndeclare const Zone: any;\r\n\r\nclass BlockUntilFirstOperator<T> implements Operator<T, T> {\r\n  private task: any = null;\r\n\r\n  constructor(private zone: NgZone) {}\r\n\r\n  call(subscriber: Subscriber<T>, source: Observable<T>): TeardownLogic {\r\n    const unscheduleTask = this.unscheduleTask.bind(this);\r\n    this.task = this.zone.run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));\r\n\r\n    return source.pipe(\r\n      tap({ next: unscheduleTask, complete: unscheduleTask, error: unscheduleTask })\r\n    ).subscribe(subscriber).add(unscheduleTask);\r\n  }\r\n\r\n  private unscheduleTask() {\r\n    // maybe this is a race condition, invoke in a timeout\r\n    // hold for 10ms while I try to figure out what is going on\r\n    setTimeout(() => {\r\n      if (this.task != null && this.task.state === 'scheduled') {\r\n        this.task.invoke();\r\n        this.task = null;\r\n      }\r\n    }, 10);\r\n  }\r\n}\r\n\r\n\r\nexport function keepUnstableUntilFirst(ngZone: NgZone) {\r\n  return <T>(obs$: Observable<T>): Observable<T> => {\r\n    obs$ = obs$.lift(\r\n      new BlockUntilFirstOperator(ngZone)\r\n    );\r\n\r\n    return obs$.pipe(\r\n      // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)\r\n      subscribeOn(ngZone.runOutsideAngular(() => new ɵZoneScheduler(Zone.current))),\r\n      // Run operators inside the angular zone (e.g. side effects via tap())\r\n      observeOn(ngZone.run(() => new ɵZoneScheduler(Zone.current, asyncScheduler))),\r\n    );\r\n  }\r\n}","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}